# JVM篇幅一

##   Java体系结构

jvm就是二进制字节码的运行环境.

特点

1.一次编译，到处运行 (javac)

2.自动内存管理

3.自动垃圾回收功能

![image-20211226023805408](picture/image-20211226023805408.png)

### 基于栈的指令架构

Java编译器输入的指令流基本上是一种**基于栈的指令架构**, 另一种是是基于寄存器的指令集架构.

基于栈式架构的特点:

> 设计和实现更简单，适用于资源受限的系统；
> 避开了寄存器的分配难题：使用零地址指令方式分配;
> 指令流中的指令大部分是零地址指令，其执行过程依赖于操作栈。指令集更小,编译器容易实现。
> 不需要硬件支持，可移植性更好，更好实现跨平台

基于寄存器架构的特点:

> 指令集架构则完全依赖硬件，可移植性差
> 性能优秀和执行更高效；
> 花费更少的指令去完成一项操作。
> 在大部分情况下，基于寄存器架构的指令集往往都以一地址指令、二地址指令和三地址指令为主，而基于栈式架构的指令集却是以零地址指令为主。

两种架构执行同样功能需要的指令:

以执行2+3这种逻辑操作为例:

基于栈的计算流程(jvm):

```
iconst_2	//常量2入栈
istore_1
iconst_3	//常量3入栈
istore_2
iload_1
iload_2
iadd		//常量2 3出栈,执行相加
istore_0	//结果5入栈
```

而基于寄存器的计算流程:

```
mov eax,2
add eax,3
```

指令集分别为8位 16位

由于跨平台性的设计 java的指令都是根据栈来设计。

不同平台cpu架构不同所以不能设计位基于寄存器的架构

## 类加载子系统

### 类加载的过程

类加载器子系统负责从文件系统或者网络中加载Class文件，class文件在文件开
头有特定的文件标识(魔数)。

ClassLoader只负责class文件的加载，至于它是否可以运行，则由Execution
Engine决定。

加载的类信息存放于一块称为**方法区**的内存空间。**除了类的信息外，方法区中还会**
**存放运行时常量池信息，可能还包括字符串字面量和数字常量（这部分常量信息是**
**Class文件中常量池部分的内存映射）**

类加载的过程:

加载 --> 链接( 验证 --> 准备 --> 解析) --> 初始化 

**加载**:
1．通过一个类的全限定名获取定义此类的**二进制字节流**
2．将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构
3．在内存中生成一个代表这个类的java.lang.**Class对象**，作为方法区这个类的各种数据的访问入口

**链接**:

1.验证(Verify):
目的在于**确保Class文件的字节流中包含信息符合当前虚拟机要求**，保证被加载类的正确性，不会危害虚拟机自身安全。
主要包括四种验证，文件格式验证，元数据验证，字节码验证，符号引用验证。

2.准备（Prepare）：
为**类变量**在**方法区**中分配内存并且设置该类变量的**默认初始值**，即零值。
注意: 这里不包含用final修饰的static，因为final在编译的时候就会分配了，准备阶段会显式初始化.

3.解析(Resolve)：
将**常量池内的符号引用转换为直接引用**的过程。
事实上，解析操作往往会伴随着JVM在执行完初始化之后再执行。

> 符号引用就是一组符号来描述所引用的目标。符号引用的字面量形式明确定义在《java虚拟机规范》的Class文件格式中。
>
> 直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。
> 解析动作主要针对类或接口、字段、类方法、接口方法、方法类型等。对应常量池中的CONSTANT_Class_info、CONSTANT_Fieldref_info、CONSTANT_Methodref_info等

**初始化**:

初始化阶段就是执行类构造器方法**< clinit>()**的过程。
此方法**不需定义**，是javac编译器自动收集类中的所有**类变量的赋值动作和静态代码块中的语句**合并而来。
构造器方法中指令**按语句在源文件中出现的顺序执行**。
< clinit>()不同于类的构造器。(关联：构造器是虚拟机视角下的< init>()), 若该类具有父类，JVM会保证子类的< clinit>()执行前，父类的< clinit>()已经执行完毕。
虚拟机必须保证一个类的< clinit>()方法在多线程下被同步**加锁**。

### 类加载器

**Bootstrap Classloader**:

这个类加载使用C/C++语言实现的，嵌套在JVM内部.

它用来加载Java的核心库（JAVA_HOME/jre/lib/rt.jar、resources.jar或sun.boot.class.path路径下的内容）,用于提供JVM自身需要的类
并不继承自java .lang.ClassLoader，没有父加载器.
加载扩展类和应用程序类加载器，并指定为他们的父类加载器.
出于安全考虑，Bootstrap启动类加载器只加载包名为java、javax、sun等开头的类.

**Extension Classloader**:

Java语言编写，由sun.misc.Launcher$ExtClassLoader实现.派生于ClassLoader类

父类加载器为启动类加载器.
从java.ext.dirs系统属性所指定的目录中加载类库，或从JDK的安装目录的jre/lib/ext子目录（扩展目录）下加载类库。如果用户创建的JAR放在此目录下，也会自动由扩展类加载器加载.

**App ClassLoader**:

java语言编写，由sun.misc.Launcher$AppClassLoader实现. 派生于ClassLoader类, 父类加载器为扩展类加载器.

它负责加载环境变量classpath或系统属性java.class.path 指定路径下的类库.
该类加载是程序中**默认的类加载器**，一般来说， Java应用的类都是由它来完成加载.
通过ClassLoader#getSystemClassLoader()方法可以获取到该类加载器.

**获取当前Classloader方式**:

```
clazz.getClassloader()							//获取当前类的类加载器
Thread.currentThread().getContextClassLoader	//获取当前线程上下文的ClassLoader
classLoader.getsystemClassLoader()				//获取系统的ClassLoader
DriverManager.getCallerclassLoaader()			//获取调用者的ClassLoader
```

#### 用户自定义类加载器

在Java的日常应用程序开发中，类的加载几乎是由上述3种类加载器相互配合执行的，在必要时，我们还可以自定义类加载器，来定制类的加载方式。

Q:为什么要自定义类加载器？

A:隔离加载类; 修改类加载的方式; 扩展加载源; 防止源码泄漏

用户自定义类加载器实现步骤：
1．开发人员可以通过继承抽象类java.lang.ClassLoader类的方式，实现自己的类加载器，以满足一些特殊的需求
2.在JDK1.2之前，在自定义类加载器时，总会去继承ClassLoader类并重写loadClass()方法，从而实现自定义的类加载类，但是在JDK1.2之后已不再建议用户去覆盖loadClass()方法，而是建议把自定义的类加载逻辑写在findClass()方法中
3.在编写自定义类加载器时，如果没有太过于复杂的需求，可以直接继承URLClassLoader类，这样就可以避免自己去编写findClass()方法及其获取字节码流的方式，使自定义类加载器编写更加简洁。

#### 双亲委派机制

Java虚拟机对class文件采用的是按需加载的方式，也就是说当需要使用该类时才会将它的class文件加载到内存生成class对象。而且加载某个类的class文件时，Java虚拟机采用的是双亲委派模式，即把请求交由父类处理，它是一种任务委派模式。

工作原理:

1.如果一个类加载器收到了类加载引导类加载器请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行;

2.如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器；

3)如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，这就是双亲委派模式。

好处:

避免类的重复加载;
保护程序安全，防止核心API被随意篡改(如自定义类java.lang.String, java.lang.ShkStart, 会提示异常:SecurityException:Prohibited package name: java.lang)

**沙箱安全机制**
自定义String类，但是在加载自定义String类的时候会率先使用引导类加载器加载，而引导类加载器在加载的过程中会先加载jdk自带的文件(rt.jar包中java\lang\String.class)，报错信息说没有main方法，就是因为加载的是rt.jar包中的String类。这样可以保证对java核心源代码的保护，这就是沙箱安全机制。

> 在JVM中表示两个class对象是否为同一个类存在两个必要条件：
>
> 1.类的完整类名必须一致，包括包名。
> 2.加载这个类的ClassLoader（指ClassLoader实例对象）必须相同。
>
> 换句话说，在JVM中，即使这两个类对象(class对象)来源同一个class文件，被同一个虚拟机所加载，但只要加载它们的ClassLoader实例对象不同，那么这两个类对象也是不相等的。

#### 类加载传导规则

JVM 提供了一种类加载传导规则:  **JVM 会选择当前类的类加载器来加载所有该类的引用的类**。

对类加载器的引用:

JVM必须知道一个类型是由启动加载器加载的还是由用户类加载器加载的。如果一个类型是由用户类加载器加载的，那么JVM会将这
个类加载器的一个引用作为类型信息的一部分保存在方法区中。当解析一个类型到另一个类型的引用的时候，JVM需要保证这两个类型的类加载器是相同的。

#### 类的主动使用

Java程序对类的使用方式分为：主动使用和被动使用。
主动使用，分为七种情况：

1.创建类的实例

2.访问某个类或接口的静态变量，或者对该静态变量赋值

3.调用类的静态方法

4.反射（比如：Class.forName(":com.atguigu.Test"））

5.初始化一个类的子类

6.Java虚拟机启动时被标明为启动类的类

7.JDK 7 开始提供的动态语言支持：
java.lang.invoke.MethodHandle实例的解析结果REF getstatic、REFputStatic、REF_invokeStatic句柄对
应的类没有初始化，则初始化

**除了以上七种情况，其他使用Java类的方式都被看作是对类的被动使用，不会导致类的初始化。**

#### java9类加载器模块化

java9之前的classloader：

- bootstrap classloader加载rt.jar，jre/lib/endorsed
- ext classloader加载jre/lib/ext
- application classloader加载-cp指定的类

java9以及之后的classloader：

- bootstrap classloader加载lib/modules 

  java.base                  			 java.security.sasl

  java.datatransfer           java.xml

  java.desktop                jdk.httpserver

  java.instrument             jdk.internal.vm.ci

  java.logging                jdk.management

  java.management             jdk.management.agent

  java.management.rmi         jdk.naming.rmi

  java.naming                 jdk.net

  java.prefs                  jdk.sctp

  java.rmi                    jdk.unsupported

- ext classloader更名为platform classloader，加载lib/modules

  java.activation*            jdk.accessibility

  java.compiler*              jdk.charsets

  java.corba*                 jdk.crypto.cryptoki

  java.scripting              jdk.crypto.ec

  java.se                     jdk.dynalink

  java.se.ee                  jdk.incubator.httpclient

  java.security.jgss          jdk.internal.vm.compiler*

  java.smartcardio            jdk.jsobject

  java.sql                    jdk.localedata

  java.sql.rowset             jdk.naming.dns

  java.transaction*           jdk.scripting.nashorn

  java.xml.bind*              jdk.security.auth

  java.xml.crypto             jdk.security.jgss

  java.xml.ws*                jdk.xml.dom

  java.xml.ws.annotation*     jdk.zipfs

- application classloader加载-cp，-mp指定的类 

  jdk.aot                     jdk.jdeps
  jdk.attach                  jdk.jdi
  jdk.compiler                jdk.jdwp.agent
  jdk.editpad                 jdk.jlink
  jdk.hotspot.agent           jdk.jshell
  jdk.internal.ed             jdk.jstatd
  jdk.internal.jvmstat        jdk.pack
  jdk.internal.le             jdk.policytool
  jdk.internal.opt            jdk.rmic
  jdk.ja rtool                 jdk.scripting.nashorn.shell
  jdk.javadoc                 jdk.xml.bind*
  jdk.jcmd                    jdk.xml.ws*
  jdk.jconsole

小结

java9模块化之后，对classloader有所改造，其中一点就是将ext classloader改为platform classloader，另外模块化之后，对应的classloader加载各自对应的模块。

## 虚拟机栈

不同线程中所包含的栈帧是不允许存在相互引用的，即不可能在一个栈帧之中引用另外一个线程的栈帧。

如果当前方法调用了其他方法，方法返回之际，当前栈帧会传回此方法的执行结果给前一个栈帧，接着，虚拟机会丢弃当前栈帧，使得前一个栈帧重新成为当前栈帧。

Java方法有两种返回函数的方式，一种是正常的函数返回，使用return指外一种是抛出异常。不管使用哪种方式，都会导致栈帧被弹出。

每个栈帧中存储着：
1.局部变量表（Local Variables）
2.操作数栈（operand Stack）（或表达式栈）
3.动态链接(Dynamic Linking)  （或指向运行时常量池的方法引用）
4.方法返回地址（Return Address）（或方法正常退出或者异常退出的定义）
5.一些附加信息

### 局部变量表

**局部变量表**也被称之为**局部变量数组**或**本地变量表**

- 定义为一个数字数组，主要用于**存储方法参数和定义在方法体内的局部变量**，这些数据类型包括各类**基本数据类型**、对象引用（reference），以及**returnAddress**类型。
- 由于局部变量表是建立在线程的栈上，是线程的私有数据，因此不存在数据安全问题。
- 局部变量表所需的容量大小是在**编译期确定**下来的，并保存在方法的**Code属性的maximum local variables数据项**中。在方法运行期间是不会改变局部变量表的大小的。
- 方法嵌套调用的次数由栈的大小决定。一般来说，**栈越大，方法嵌套调用次数越多**。对一个函数而言，**它的参数和局部变量越多，使得局部变量表膨胀，它的栈帧就越大**，以满足方法调用所需传递的信息增大的需求。进而函数调用就会占用更多的栈空间，导致其嵌套调用次数就会减少。
- 局部变量表中的变量**只在当前方法调用中有效**。在方法执行时，虚拟机通过使用局部变量表完成参数值到参数变量列表的传递过程。
  当方法调用结束后，随着方法栈帧的销毁，局部变量表也会随之销毁。

**Slot**

- 参数值的存放总是在局部变量数组的**index0开始**，到数组长度**-1的索引结束**。
- 局部变量表，最基本的存储单元是Slot（变量槽）
- 局部变量表中存放编译期可知的各种**基本数据类型(8种)，引用类型（reference），returnAddress类型**。
- 在局部变量表里，，32位以内的类型只占用一个slot（包括returnAddress类型），64位的类型（long和double）占用两个slot。

> byte 、short 、char 在存储前被转换为int，boolean也被转换为int，0 表示false ，非0 表示true。
> long 和double 则占据两个slot。

JVM会为局部变量表中的每一个slot都分配一个访问索引，通过这个索引即可成功访问到局部变量表中指定的局部变量值.

当一个实例方法被调用的时候，它的方法参数和方法体内部定义的局部变量将会按照顺序被复制到局部变量表中的每一个Slot上.

**如果需要访问局部变量表中一个64bit局部变量值时，只需要使用前引即可**。（比如：访问long或double类型变量）.

**如果当前帧是由构造方法或者实例方法创建的，那么该对象引用this将会存放在index为0的slot处**，其余的参数按照参数表顺序继续排列.

> 注意:局部表里表中的变量不存在类变量的"准备阶段"的初始化, 即赋0值.
>
> **这意味着一旦定义了局部变量则必须人为的初始化，否则无法使用。**

**Slot的重复利用**

局部变量表中的slot是可以重用的，如果一个局部变量过了其作用域，那么在其**作用域之后**申明的新的局部变量就很有可能会复用过期局部变量的槽位，从而上到节省资源的目的。

### 操作数栈

每一个独立的栈帧中除了包含局部变量表以外，还包含一个后进先出（Last-In-First-Out）的操作数栈，也可以称之为表达式栈（Expression Stack）.

操作数栈，在方法执行过程中，根据字节码指令，往栈中写入数据或提取数据，即入栈（push）/出栈（pop）。

某些字节码指令将值压入操作数栈，其余的字节码指令将操作数取出栈。使用它们后再把结果压入栈。比如：执行复制、交换、求和等操作.

操作数栈，主要用于**保存计算过程是的中间结果**，同时作为**计算过程中变量临时的存储空间**。

操作数栈就是JVM执行引擎的一个工作区，当一个方法刚开始执行的时候，一个新的栈帧也会随之被创建出来，这个方法的操作数栈是空的。

**每一个操作数栈都会拥有一个明确的栈深度用于存储数值，其所需的最大深度在编译期就定义好了**，保存在方法的Code属性中，为max
x_stack的值。

栈中的任何一个元素都是可以任意的Java数据类型。**32bit的类型占用一个栈单位深度, 64bit的类型占用两个栈单位深度**.

操作数栈并非采用访问索引的方式来进行数据访问的，而是只能通过标准的入栈（push）和出栈（pop）操作来完成一次数据访问。

**如果被调用的方法带有返回值的话，其返回值将会被压入当前栈帧的操作数栈中，并更新PC寄存器中下一条需要执行的字节码指令。**

操作数栈中元素的数据类型必须与字节码指令的序列严格匹配，这由编译器在编译器期间进行验证，同时在类加载过程中的类检验阶段的数据流分析阶段要再次验证。



**栈顶缓存技术**

基于栈式架构的虚拟机所使用的零地址指令更加紧凑，但完成一项操作的时候必然需要使用更多的入栈和出栈指令，这同时也就意
味着将需要更多的指令分派（instructiondispatch）次数和内存读/写次数。

由于操作数是存储在内存中的，因此频繁地执行内存读/写操作必然会影响执行速度。为了解决这个问题，HotSpot JVM的设计者们提出了栈顶缓存（ToS，Top-of-Stack Cashing）技术，**将栈顶元素全部缓存在物理CPU的寄存器中，以此降低对内存的读/写次数，提升执行引擎的执行效率。**

### 动态链接

**每一个栈帧内部都包含一个指向运行时常量池中该栈帧所属方法的引用**。包含这个引用的目的就是为了支持当前方法的代码能够实现
动态链接(Dynamic Linking), 比如：invokedynamic指令

**在Java源文件被编译到字节码文件中时，所有的变量和方法引用都作为符号引用（Symbolic Reference）保存在class文件的常量池里。**
比如：描述一个方法调用了另外的其他方法时，就是通过常量池中指向方法的符号引用来表示的，那么动态链接的作用就是为了将这些符号引用转换为调用方法的直接引用。

> 常量池的作用，就是为了提供些符号和常量，便于指令的识别。

### 方法的调用

在JVM中，将符号引用转换为调用方法的直接引用与方法的绑定机制相关。

**静态链接**：当一个字节码文件被装载进JVM内部时，如果被调用的目标方法在编译期可知，且运行期保持不变时。这种情况下将调用方法的符号引用转换为直接引用的过程称之为静态链接。

**动态链接**：如果被调用的方法在编译期无法被确定下来，也就是说，只能够在程序运行期将调用方法的符号引用转换为直接引用，由于这种引用转换过程具备动态性，因此也就被称之为动态链接。

对应的方法的绑定机制为：早期绑定（Early Binding）和晚期绑定（Late Binding））。绑定是一个字段、方法或者类在符号引用被替换为直接引用的过程，这仅仅发生一次。

**早期绑定**：早期绑定就是指被调用的目标方法如果在编译期可知，且运行期保持不变时，即可将这个方法与所属的类型进行绑定，这样一来，由于明确了被调用的目标方法究竟是哪一个，因此也就可以使用静态链接的方式将符号引用转换为直接引用。

**晚期绑定**：如果被调用的方法在编译期无法被确定下来，只能够在程序运行期根据实际的类型绑定相关的方法，这种绑定方式也就被称之为晚期绑定。

>  随着高级语言的横空出世，类似于Java一样的基于面向对象的编程语言如今越来越多，尽管这类编程语言在语法风格上存在一定的差别，但是它们彼此之间始终保持着一个共性，那就是都支持封装、继承和多态等面向对象特性，既然这一类的编程语言具备多态特性，那么自然也就具备早期绑定和晚期绑定两种绑定方式。

**虚函数**

Java中任何一个普通的方法其实都具备虚函数的特征，它们相当于c++语言中的虚函数（C++中则需要使用关键字virtual来显式定义）。如果在Java程序中不希望某个方法拥有虚函数的特征时，则可以使用关键字final来标记这个方法。

非虚方法：如果方法在编译期就确定了具体的调用版本，这个版本在运行时是不可变的。这样的方法称为非虚方法。
静态方法、私有方法、final方法、实例构造器、父类方法都是非虚方法。其他方法称为虚方法。

> 子类对象的多态性的使用前提：①类的继承关系 ② 方法的重写

**方法调用指令**

普通调用指令：
1. invokestatic：调用静态方法，解析阶段确定唯一方法版本
2. invokespecial：调用< init>方法、私有及父类方法，解析阶段确定唯一方法版本
3. invokevirtual：调用所有虚方法
4. invokeinterface：调用接口方法

动态调用指令：

​	5．invokedynamic：动态解析出需要调用的方法，然后执行.

前四条指令固化在虚拟机内部，方法的调用执行不可人为干预，而invokedynamic指令则支持由用户确定方法版本。其中
invokestatic指令和invokespecial指令调用的方法称为非虚方法，其余的（final修饰的除外）称为虚方法。

**关于invokedynamic**

JVM字节码指令集一直比较稳定，直到Java7中才增加了一个invokedynamic指令，这是JAVA为了实现**动态类型语言**支持
故的一种改进。

但是在Java7中并没有提供直接生成invokedynamic指令的方法，需要借助ASM这种底层字节码工具来产生invokedynamic指令。直到**Java8的Lambda表达式的出现，invokedynamic指令的生成，在Java中才有了直接的生成方式。**

**方法的重写**

方法重写的本质:

1.找到操作数栈顶的第一个元素所执行的对象的实际类型，记作 C。

2.如果在类型 C 中找到与常量中的描述符合简单名称都相符的方法，则进行访问权限校验，如果通过则返回这个方法的直接引用，查找过程结束；如果不通过，则返回java.lang.IllegalAccessError 异常。

3.否则，按照继承关系从下往上依次对 C 的各个父类进行第 2 步的搜索和验证过程。

4.如果始终没有找到合适的方法，则抛出java.lang.AbstractMethodError异常。

这个过程影响效率, 从而出现了虚方法表

**虚方法表**

在面向对象的编程中，会很频繁的使用到动态分派，如果在每次动态分派的过程中都要重新在类的方法元数据中搜索合适的目标的话就可能影响到执行效率。因此，**为了提高性能**，JVM采用在类的方法区建立一个虚方法表(virtual method table）(非虚方法不会出现在表中)来实现。使用索引表来代替查找。

**方法的返回值**

存放调用该方法的PC寄存器的值

一个方法的结束，有两种方式：
1.正常执行完成;
2 出现未处理的异常，非正常退出.

无论通过哪种方式退出，在方法退出后都返回到该方法被调用的位置。

方法正常退出时，调用者的pc计数器的值作为返回地址，即**调用该方法的指令的下一条指令的地址**。

而通过异常退出的，返回地址是要通过异常表来确定，栈帧中一般不会保存这部分信息。

当一个方法开始执行后，只有两种方式可以退出这个方法：
1.执行引擎遇到任意一个方法返回的字节码指令（return），会有返回值传递给上层的方法调用者，简称正常完成出口:

一个方法在正常调用完成之后究竟需要使用哪一个返回指令还需要根据方法返回值的实际数据类型而定。
在字节码指令中，返回指令包含ireturn（当返回值是boolean、byte、char、short和int类型时使用）、lreturn、freturn、dreturn以及areturn，另外还有一个return指令供声明为void的方法、实例初始化方法、类和接口的初始化方法使用。

2.在方法执行的过程中遇到了异常（Exception）并且这个异常没有在方法内进行处理，也就是只要在本方法的异常表中没有搜索到匹配的异常处理器，就会导致方法退出。简称异常完成出口。

方法执行过程中抛出异常时的异常处理，存储在一个异常处理表，方便在发生异常的时候找到处理异常的代码。

> 本质上，方法的退出就是当前栈帧出栈的过程。此时，需要恢复上层方法的局部变量表、操作数栈、将返回值压入调用者栈帧的操作数栈、设置PC寄存器值等，让调用者方法继续执行下去。

## 本地方法栈

**本地方法**

简单地讲，一个Native Method就是一个Java调用非Java代码的接口。一个Native Method是这样一个Java方法：该方法的实现由非Java语言实现，比如c。这个特征并非Java所特有，很多其它的编程语言都有这一机制，比如在C++中，你可以用extern "C"告知C++编译器去调用一个c的函数。

在定义一个native method时，并不提供实现体（有些像定义一个Javainterface），因为其实现体是由非java语言在外面实现的。
本地接口的作用是融合不同的编程语言为Java所用，它的初衷是融合 C/C++程序。

为什么使用native method?

1.与java环境外交互;

2.与操作系统交互.

**现状**

目前该方法使用的越来越少了，除非是与硬件有关的应用，比如通过Java程序驱动打印机或者Java系统管理生产设备，在企业级应用中已经比较少见。因为现在的**异构领域间的通信**很发达，比如可以使用Socket通信，也可以使用Web Service等等，不多做介绍。

**本地方法栈**

Java虚拟机栈用于管理Java方法的调用,而本地方法栈用于管理本地方法的调用.

本地方法栈，也是线程私有的。
允许被实现成固定或者是可动态扩展的内存大小。（在内存溢出方面是相同的）

> 如果线程请求分配的栈容量超过本地方法栈允许的最大容量，Java虚拟机将会抛出一个 StackoverflowError 异常。

> 如果本地方法栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的本地方法栈，那么Java虚拟机将会抛出一个 OutOfMemoryError 异常。

本地方法是使用c语言实现的。它的具体做法是Native Method Stack中登记native方法，在Execution Engine 执行时加载本地方法库。

当某个线程调用一个本地方法时，它就进入一个全新的并且不再受虚拟机限制的世界。它和虚拟机拥有同样的权限

> 本地方法可以通过本地方法接口来访问虚拟机内部的运行时数据区。
> 它甚至可以直接使用本地处理器中的寄存器
> 直接从本地内存的堆中分配任意数量的内存。

并不是所有的JVM都支持本地方法。因为Java虚拟机规范并没有明确要求本地方法栈的使用语言、具体实现方式、数据结构等。如果JVM产品不打算支持native方法，也可以无需实现本地方法栈。

> Hotspot jvm中 直接将本地方法栈与虚拟机栈合二为一

## 堆

一个JVM实例只存在一个堆内存，堆也是Java内存管理的核心区域。

Java 堆区在JVM启动的时候即被创建，其空间大小也就确定了。是JVM管理的最大一块内存空间。(堆内存的大小是可以调节的)

《Java虚拟机规范》规定，**堆可以处于物理上不连续的内存空间中，但在逻辑上它应该被视为连续的。**

所有的线程共享Java堆，在这里还可以划分线程私有的缓冲区（ThreadLocal Allocation Buffer **TLAB**)。

《Java虚拟机规范》中对Java堆的描述是：**所有的对象实例以及数组都应当在运行时分配在堆上**。(现在不一定:根据逃逸分析进行栈上分配)

在方法结束后，堆中的对象不会马上被移除，仅仅在垃圾收集的时候才会被移除。

### 堆空间参数设置

```java
 * 1. 设置堆空间大小的参数
 * -Xms 用来设置堆空间（年轻代+老年代）的初始内存大小
 *      -X 是jvm的运行参数
 *      ms 是memory start
 * -Xmx 用来设置堆空间（年轻代+老年代）的最大内存大小
 * 通常会将 -Xms 和 -Xmx两个参数配置相同的值，其目的是为了自在java垃圾收机制清理完堆区后不需要重新分隔计算堆区的大小，从而提高性能。
 * 2. 默认堆空间的大小
 *    初始内存大小：物理电脑内存大小 / 64
 *    最大内存大小：物理电脑内存大小 / 4
 *    物理电脑内存大小实际上是小于原物理内存大小的
 * 3. 手动设置：-Xms600m -Xmx600m
 *     开发中建议将初始堆内存和最大的堆内存设置成相同的值。
 *       最大堆内存如果大于初始堆内存在所用内存不足时进行扩容，会影响系统性能
 * 4. 查看设置的参数：方式一：命令行（环境变量） jps ：查看当前进程 /  jstat -gc 进程id   查看进程内存使用情况
 *                   老年代 OC：总量 OU：已使用
 *                   新生代 EC: 伊甸园区总量 EU：伊甸园区已使用
 *                         S0C: S0区总量  S0U：S0区已使用
 *                         S1C:           S1U:
 *                         S0C（或S1C）+EC+OC=Runtime.getRuntime().totalMemory()
 *                         S0与S1  同时只有一个与伊甸园区配合使用
 *                  方式二：-XX:+PrintGCDetails
 *                  jdk文件下bin目录下的jvisualvm.exe 查看
 *                   jdk8以前自带 jdk9以及以后需自行下载 且需要在解压文件的etc目录下的visualvm.conf文件下加入jdk路径
 *                   在bin下启动  且安装visual gc插件
 *                  在visual GC 的graphs项中能看到
 *                   Eden Space、Survivor 0、Survivor 1、Old Gen 的第二个 参数加起来和为 10M
```

```java
* -XX:NewRatio ： 设置新生代与老年代的比例。默认值是2. 即新生代1 老年代2
* 可命令行 jinfo -flag NewRatio 进程id 查看    
* -XX:SurvivorRatio ：设置新生代中Eden区与Survivor区的比例。默认值是8 即8 1 1 自适应为6 即6 1 1
* 、可命令行 jinfo -flag SurvivorRatio 进程id 查看  
* -XX:-UseAdaptiveSizePolicy ：关闭自适应的内存分配策略  （暂时用不到）  -：关闭 
* -Xmn:设置新生代的空间的大小。 （一般不设置：因为会设置堆的总大小与新老年代比例后间接设置了此参数）
```

### 特殊晋升规则

1.如果对象的大小比伊甸园区的容量大，直接考虑放入老年区。

2.动态对象年龄判断：当幸存者区中低于某个年龄的对象容量大于幸存者区容量的一半时, 高于该年龄的对象全部担保到老年区.

3.空间分配担保: Minor GC之前, jvm检查老年代最大可用的连续空间是否大于新生代所有对象的总空间, 如果大于,则这次Minor GC是安全的; 否则, 会先检查 `-XX:HandlePromotionFailure`参数的设置值**是否允许担保失败**; 如果允许, 那么会继续判断老年代**最大可用的连续空间**是否大于历次晋升到老年代对象的平均大小, 如果大于, 将尝试一次Minor GC, 尽管这次Minor GC是有风险的; 如果小于或者参数不允许, 则进行Full GC

这里的前提 不允许动态扩建堆。

### 逃逸分析

在《深入理解Java虚拟机》中关于Java堆内存有这样一段描述：随着JIT编译期的发展与逃逸分析技术逐渐成熟，栈上分配、标量替换优化技术将会导致一些微妙的变化，所有的对象都分配到堆上也渐渐变得不那么“绝对”了。

在Java虚拟机中，对象是在Java堆中分配内存的，这是一个普遍的常识。但是，有一种特殊情况，那就是如果经过逃逸分析(EscapeAnalysis)后发现对象并没有逃逸出方法的话，那么就可能被优化成栈上分配。这样就无需在堆上分配内存，也无须进行垃圾回收了。这也是最常见的堆外存储技术。

**栈上分配**

JIT编译器在编译期间根据逃逸分析的结果，发现如果一个对象并没有逃逸出方法的话，就可能被优化成栈上分配。分配完成后，继续在调用栈内执行，最后线程结束，栈空间被回收，局部变量对象也被回收。这样就无须进行垃圾回收了。

**同步消除**

线程同步的代价是相当高的，同步的后果是降低并发性和性能。
所以在动态编译同步块的时候，JIT编译器可以借助逃逸分析来判断同步块所使用的锁对象是否只能够被一个线程访问而没有被发布到其他线程。如果没有，那么JIT编译器在编译这个同步块的时候就会取消对这部分代码的同步。这样就能大大提高并发性和性能。这个取消同步的过程就叫同步省略，也叫锁消除。(偏向锁?)

**标量替换**

标量（Scalar）是指一个无法再分解成更小的数据的数据。Java中的原始数据类型就是标量。相对的，那些还可以分解的数据叫做聚合量
ate）.

Java中的对象就是聚合量，因为他可以分解成其他聚合量和标量。

在JIT阶段，如果经过逃逸分析，发现一个对象不会被外界访问的话，那么经过JIT优化，就会把这个对象拆解成若干个其中包含的若干个成员变量来代替。这个过程就是标量替换。

> 但是,目前逃逸分析技术并不是十分成熟: 其根本原因就是无法保证逃逸分析的性能消耗一定能高于他的消耗。虽然经过逃逸分析可以做标量替换、栈上分配、和锁消除。但是逃逸分析自身也是需要进行一系列复杂的分析的，这其实也是一个相对耗时的过程。

## 方法区

方法区（Method Area）与Java堆一样，是各个线程共享的内存区域。

方法区在JVM启动的时候被创建，并且它的实际的物理内存空间中和Java堆区一样都可以是不连续的。

方法区的大小，跟堆空间一样，可以选择固定大小或者可扩展。

方法区的大小决定了系统可以保存多少个类，如果系统定义了太多的类，导致方法区溢出，虚拟机同样会抛出内存溢出错误：
java.lang.OutOfMemoryError：PermGen space或者 java.lang.OutOfMemoryError：Metaspace .
比如加载大量的第三方的jar包；Tomcat部署的工程过多（30-50个),大量动态的生成反射类

关闭JVM就会释放这个区域的内存。

> jdk8中，类元数据存储在本地内存中，这个空间叫元空间。
>
> 以前永久代为方法区属于jvm内存一部分所以容易oom，现在元空间为方法区，属于本地内存了，在jvm外。
>
> 本地内存不足时oom 

**方法区存储类型信息**

对每个加载的类型（类class、接口interface、枚举enum、注解annotation），JVM必须在方法区中存储以下类型信息：
① 这个类型的完整有效名称（全名=包名.类名）
② 这个类型直接父类的完整有效名(对于interface或是java .lang.Object，都没有父类）
③ 这个类型的修饰符(public,abstract, final的某个子集)
④ 这个类型直接接口的一个有序列表

还有Field信息, Method信息, non-final类变量信息

> 注意: static final  全局常量在编译时就会被分配了. 
>
> 即在字节码文件中可以看到其值 ,而非final的类变量在初始化clinit时候赋值  

### 常量池与运行时常量池

运行时常量池（Runtime Constant Pool）是方法区的一部分。

常量池表（Constant Pool Table）是Class文件的一部分，用于存放编译期生成的各种字面量与符号引用，这部分内容将在**类加载后存放到方法区的运行时常量池中**。

运行时常量池，在加载类和接口到虚拟机后，就会创建对应的运行时常量池。

JVM为每个已加载的类型（类或接口）都维护一个常量池。池中的数据项像数组项一样，是通过索引访问的

运行时常量池中包含多种不同的常量，包括编译期就已经明确的数值字面量，也包括到运行期解析后才能够获得的方法或者字段引用。此时不再是常量池中的符号地址了，这里换为真实地址。

当创建类或接口的运行时常量池时，如果构造运行时常量池所需的内存空间超过了方法区所能提供的最大值，则JVM会抛OutOfMemoryError异常。

### 方法区的演进

1．首先明确：只有HotSpot才有永久代。BEA JRockit、IBM J9等来说，是不存在永久代的概念的。原则上如何实现方法区属于虚拟机实现细节，不受《Java虚拟机规范》管束，并不要求统
2．Hotspot中方法区的变化：

| jdk1.6及之前 | 有永久代(permanentgeneration),静态变量存放在永久代上         |
| ------------ | ------------------------------------------------------------ |
| jdk1.7       | 有永久代，但已经逐步“去永久代”，字符串常量池、静态变量移除，保存在堆中 |
| jdk1.8及之后 | 无永久代，类型信息、字段、方法、常量保存在本地内存的元空间，但字符串常量池、静态变量仍在堆 |

元空间( Metaspace)为一个与堆不相连的本地内存区域

由于类的元数据分配在本地内存中， 元空间的最大可分配空间就是系统可用内存空间。

这项改动是很有必要的，原因有：

1）为永久代设置空间大小是很难确定的。

在某些场景下，如果动态加载类过多，容易产生Perm 区的OOM。
比如某个实际Web工程中，因为功能点比较多，在运行过程中，要不断动态加载很多类，经常出现致命错误。

而元空间和永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存。
因此，默认情况下，元空间的大小仅受本地内存限制。

2）对永久代进行调优是很困难的。

**StringTable为什么调整**?

jdk7中将StringTable放到了堆空间中。因为永久代的回收效率很低，在full gc的时候才会触发。而full gc是老年代的空间不足、永久代不足时才会触发。这就导致StringTable回收效率不高。而我们开发中会有大量的字符串被创建，回收效率低，导致永久代内存不足。放到堆里，能及时回收内存。

## 对象创建过程

 1.虚拟机遇到一条new指令，首先区检查这个指令的参数能否在Metaspace的常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已经加载、解析和初始化。（即判断类元信息是否存在）。如果没有，那么在双亲委派模式下，使用当前类加载器以ClassLoader+包名+类名为Key进行查找对应的.class文件，如果没有找到文件,则抛出ClassNotFoundException异常，如果找到，则进行类加载，并生成对应的Class类对象。

2.为对象分配内存：首先计算对象占用空间大小，接着在堆中划分一块内存给对象。如果实例成员变量是引用变量，仅分配引用变量空间即可，即4字节大小。

如果内存规时规整的，那么虚拟机将采用的是指针碰撞法来为对象分配内存。指针碰撞法意思是所有用过的内存在一边，空闲的内存在另一边，中间放着一个指针作为分界点的指示器，分配内存就仅仅是把指针指向空闲的那边挪动一段与对象大小相等的距离罢了。如果垃圾收集器选择的是Serial、ParNew这种基于压缩算法的，虚拟机采用这种分配方式，一般使用带有compact（整理）过程的收集器时，使用指针碰撞。

如果内存不规整：虚拟机需要维护一个列表：空间列表分配法，意思是虚拟机维护了一个列表，记录上那些内存块是可用的，再分配的时候从列表中找到一块足够大的空间划分给对象实例并更新列表上的内容。

>  说明：选择哪种分配方式由java堆是否规整决定，而java堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。

3.处理并发问题: 每个线程分配一块TLAB , 优先在TLAB上分配, 如果满了则加锁分配.

4.初始化分配空间.

5.设置对象的对象头：  将对象的所属类（即类的元数据信息）、对象的hashcode和对象的gc信息、锁信息等数据存储在对象头中。这个过程的具体设置方式取决于jvm的实现

6.init：从java程序的视角来看，初始化才正式开始，初始化成员变量，执行实例化代码块，调用类的构造方法，并把堆内对象的首地址赋给引用变量。因此一般来说（由字节码中是否跟随由invokespecial指令所决定），new指令之后会接着就是执行方法，把对象按照程序员的意愿进行初始化，这样一个真正的可用的对象才算完全创建出来。

>  访问对象可通过下列两种方式:
>
> 句柄访问：引用中存储稳定句柄地址，对象被移动时（在垃圾回收时移动对象很普遍）只会改变句柄中实例数据指针即可，引用本身不需要被修改。
>
> 直接指针（Hotspot使用）：引用直接指向实例数据，效率高，速度快

## 对象的内存布局

1.对象头

包括运行时元数据(Mark word) 和 类型指针;

Mark Word 又包含: 哈希值, GC分代年龄, 锁状态标志, 线程持有的锁, 偏向线程ID, 偏向时间戳

类型指针指向类元数据,确定该对象所属的类型.

> 如果是数组, 还需要记录数据的长度

2.实例数据

对象真正存储的有效信息

内存布局规则为: 相同宽度的字段总是被分配在一起; 父类中定义的变量会出现在子类之前; 如果CompactFields参数为true(默认), 子类的窄变量可能插入到父类变量的空隙中.

3.对齐填充



## 执行引擎

“虚拟机”是一个相对于“物理机”的概念，这两种机器都有代码执行能力，其区别是物理机的执行引擎是直接建立在处理器、缓存、指令集
和操作系统层面上的，而虚拟机的执行引擎则是由软件自行实现的，因此可以不受物理条件制约地定制指令集与执行引擎的结构体系，
能够执行那些不被硬件直接支持的指令集格式。

JVM的主要任务是负责装载字节码到其内部，但字节码并不能够直接运行在操作系统之上，因为字节码指令并非等价于本地机器指令，它内部包含的仅仅只是一些能够被JVM所识别的字节码指令、符号表，以及其他辅助信息。

那么，如果想要让一个Java程序运行起来，执行引擎(Execution Engine)的任务就是将字节码指令解释/编译为对应平台上的本地机器指令才可以。简单来说，JVM中的执行引擎充当了将高级语言翻译为机器语言的译者。

JAVA代码执行分为两类:

**解释器**：当Java虚拟机启动时会根据预定义的规范对字节码采用逐行解释的方式执行，将每条字节码文件中的内容“翻译”为对应平台的本地机器指令执行。

**JIT（Just In Time Compiler)编译器**：就是虚拟机将源代码直接编译成和本地机器平台相关的机器语言。

> JVM在执行代码的时候, 通常会将解释执行与编译执行二者结合.

### JIT编译器

概念解释：

Java 语言的 “编译期”其实是一段“不确定”的操作过程，因为它可能是指一个**前端编译器**（其实叫
“编译器的前端”更准确一些）把 .java文件转变成 .class文件的过程；

也可能是指虚拟机的后端运行期编译器（JIT 编译器，Just In Time Compiler)把字节码转变成机器码的过程。

还可能是指使用静态提前编译器（AOT 编译器，Ahead Of Time Compiler）直接把.java文件编译成本地机器代码的过程。

> 前端编译器：Sun 的 Javac、Eclipse JDT 中的增量式编译器(ECJ)
> JIT 编译器：HotSpot VM 的 C1、C2 编译器。
> AOT 编译器：GNU Compiler for the Java (GCJ), Excelsior JET.

**如何选择JIT? -- 热点探测**

是否需要启动JIT编译器将字节码直接编译为对应平台的本地机器指令需要根据代码被调用执行的频率而定。关于那些需要被编译为本地代码的字节码，也被称之为"热点代码”. **JIT编译器在运行时会针对那些频繁被调用的“热点代码”做出深度优化，将其直接编译为对应平台的本地机器指令，以此提升Java程序的执行性能。**

一个被多次调用的方法，或者是一个方法体内部循环次数较多的循环体都可以被称之为“热点代码”，因此都可以通过JIT编译器编译为本地机器指令。由于这种编译方式发生在方法的执行过程中，因此也被称之为栈上替换，或简称为JOSR（On Stack
Replacement）编译。

一个方法究竟要被调用多少次，或者一个循环体究竟需要执行多少次循环才可以达到这个标准？必然需要一个明确的阈值，JIT编译器才会将这些“热点代码”编译为本地机器指令执行。这里主要依靠热点探测功能。

目前HotSpot所采用的热点探测方式是基于计数器的热点探测。

采用基于计数器的热点探测，HotSpot VM将会为每一个方法都建立2个不同类型的计数器，分别为方法调用计数器（Invocation Counter）和回边计数器（Back Edge Counter）

**方法调用计数器**用于统计方法的调用次数

这个计数器就用于统计方法被调用的次数，它的默认阈值在 Client 模式下是 1500 次，在 Server
模式下是 10000次。超过这个阈值，就会触发JIT编译。

这个阈值可以通过虚拟机参数-XX:CompileThreshold来人为设定。

当一个方法被调用时，会先检查该方法是否存在被 JIT 编译过的版本，如果存在，则优先使用编译后的本地代码来执行。如果不存在已被编译过的版本，则将此方法的调用计数器值加 1，然后判断方法调用计数器与回边计数器值之和是否超过方法调用计数器的阈值。如果已超过阈值，那么将会向即时编译器提交一个该方法的代码编译请求。

> 热度衰减:
>
> 如果不做任何设置，方法调用计数器统计的并不是方法被调用的绝对次数，而是一个相对的执行频率，即一段时间之内方法被调用的次数。当超过一定的时间限度，如果方法的调用次数仍然不足以让它提交给即时编译器编译，那这个方法的调用计数器就会被减少一半，这个过程称为方法调用计数器热度的衰减（Counter Decay），而这段时间就称为此方法统计的半衰周期（Counter Half Life Time）
>
> 进行热度衰减的动作是在虚拟机进行垃圾收集时顺便进行的，可以使用虚拟机参数-XX:-UseCounterDecay来关闭热度衰减，让方法计数器统计方法调用的绝对次数，这样，只要系统运行时间足够长，绝大部分方法都会被编译成本地代码。
>
> 另外，可以使用-XX:CounterHalfLifeTime 参数设置半衰周期的时间，单位是秒。

**回边计数器**则用于统计循环体执行的循环次数

它的作用是统计一个方法中循环体代码执行的次数，在字节码中遇到控制流向后跳转的指令称为
“回边”（Back Edge）。显然，建立回边计数器统计的目的就是为了触发OSR 编译。



**HotSpot VM中JIT分类**

在HotSpot VM中内嵌有两个JIT编译器，分别为Client Compiler和ServerCompiler，但大多数情况下我们简称为C1编译器和C2编译器。开发人员可以通过如下命令显式指定Java虚拟机在运行时到底使用哪一种即时编译器，如下所示：

-client：指定Java虚拟机运行在Client模式下，并使用C1编译器；

C1编译器会对字节码进行简单和可靠的优化，耗时短。以达到更快的编译速度。

-server：指定Java虚拟机运行在Server模式下，并使用C2编译器。

C2进行耗时较长的优化，以及激进优化。但优化的代码执行效率更高。

> 分层编译（Tiered Compilation）策略：程序解释执行（不开启性能监控）可以触发C1编译，将字节码编译成机器码，可以进行简单优化，也可以加上性能监控，C2编译会根据性能监控信息进行激进优化。
>
> 不过在Java7版本之后，一旦开发人员在程序中显式指定命令“-server’时，默认将会开启分层编译策略，由C1编译器和C2编译器相互协作共同来执行编译任务。

> 64位JDK仅支持-server

**C1和C2编译器不同的优化策略**：

在不同的编译器上有不同的优化策略，C1编译器上主要有方法内联，去虚拟化、冗余消除。

> 方法内联：将引用的函数代码编译到引用点处，这样可以减少栈帧的生成，减少参数传递以及跳转过程
> 去虚拟化：对唯一的实现类进行内联
> 冗余消除：在运行期间把一些不会执行的代码折叠掉

C2的优化主要是在全局层面，逃逸分析是优化的基础。基于逃逸分析在C2上有如下几种优化：

> 标量替换：用标量值代替聚合对象的属性值
> 栈上分配：对于未逃逸的对象分配对象在栈而不是堆
> 同步消除：清除同步操作，通常指synchronized

一般来说,JIT编译出来的机器码性能比解释器高 .

而c2编译器启动时间比c1编译器慢, 系统稳定执行以后, c2编译器执行速度远远快于c1编译器,



## String相关

### 拼接

1.如果拼接符号的前后出现了变量，则相当于在堆空间中new String()

2.被final修饰的String在拼接时是作为常量来拼接的

3.字符串拼接操作不一定使用的是StringBuilder!  如果拼接符号左右两边都是字符串常量或常量引用，则仍然使用编译期优化，即非StringBuilder的方式。

4.通过StringBuilder的append()的方式添加字符串的效率要远高于使用String的字符串拼接方式！

StringBuilder的append()的方式：自始至终中只创建过一个StringBuilder的对象 , 而使用String的字符串拼接方式：创建过多个StringBuilder和String的对象

5.在实际开发中，如果基本确定要前前后后添加的字符串长度不高于某个限定值highLevel的情况下,建议通过构造函数设置：

```
StringBuilder s = new StringBuilder(highLevel);//new char[highLevel]
```



### new String()

```
 * new String("ab")会创建几个对象？看字节码，就知道是两个。
 *     一个对象是：new关键字在堆空间创建的          new #2<java/lang/String>
 *     另一个对象是：字符串常量池中的对象"ab"。 字节码指令：ldc #3 <ab>
 *
 *
 * 思考：
 * new String("a") + new String("b")呢？   6个
 *  对象1：new StringBuilder()           new #2 <java/lang/StringBuilder>
 *  对象2： new String("a")              new #4 <java/lang/String>
 *  对象3： 常量池中的"a"                 ldc #5 <a>
 *  对象4： new String("b")              new #4 <java/lang/String>
 *  对象5： 常量池中的"b"                 ldc #8 <b>
 *
 *  深入剖析： StringBuilder的toString():
 *  对象6 ：new String("ab")
 *  强调一下，toString()的调用，在字符串常量池中，没有生成"ab"  因为toString的参数为变量
```

### Intern()

jdk1.6中，将这个字符串对象尝试放入串池。如果串池中有，则并不会放入。返回已有的串池中的对象的地址; 如果没有，会把此对象复制一份，放入串池，并返回串池中的对象地址

Jdk1.7起，将这个字符串对象尝试放入串池。如果串池中有，则并不会放入。返回已有的串池中的对象的地址; 如果没有，则会把对象的引用地址复制一份，放入串池，并返回串池中的引用地址.

### G1的String去重

许多大规模的Java应用的瓶颈在于内存，测试表明，在这些类型的应用里面，Java堆中存活的数据集合差不多25%是String对象。更进一步，这里面差不多一半String对象是重复的，重复的意思是说：stringl.equals(string2)=true。

堆上存在重复的String对象必然是一种内存的浪费。这个项目将在G1垃圾收集器中实现自动持续对重复的String对象进行去重，这样就能避免浪费内存。

> 注意: 常量池本身就是不重复的
>
> String str1 = new String("hello");
>
> String str2 = new String("hello");
>
> 针对的是该类去重

**G1的String去重操作实现**

- 当垃圾收集器工作的时候，会访问堆上存活的对象。对每一个访问的对象都会检查是否是候选的要去重的String对象。
- 如果是，把这个对象的一个引用插入到队列中等待后续的处理。一个去重的线程在后台运行，处理这个队列。处理队列的一个元素意味着从队列删除这个元素，然后尝试去重它引用的String对象。
- 使用一个hashtable来记录所有的被String对象使用的不重复的char数组。当去重的时候，会查这个hashtable，来看堆上是否已经存在一个一模一样的char数组。
- 如果存在，String对象会被调整引用那个数组，释放对原来的数组的引用，最终会被垃圾收集器回收掉。

> G1的去重默认是不开启的, 相关参数为:
>
> UseStringDeduplication(bool):开启String去重，默认是不开启的，需要手动开启。
>
> PrintStringDeduplicationstatistics (bool):打印详细的去重统计信息
>
> StringDeduplicationAgeThreshold (uintx):达到这个年龄的String对象被认为是去重的候选对象

